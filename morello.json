{
  "name": "Morello",
  "files": [
    "prelude.sail",
    "builtins.sail",
    "decode_start.sail",
    "v8_base.sail",
    "v8post.sail",
    "version.sail",
    "config.sail",
    "config_list.sail",
    "events.sail",
    "interrupts.sail",
    "fetch.sail",
    "mem.sail",
    "reset.sail",
    "semihost.sail",
    "v8debug.sail",
    "counters.sail",
    "instrs.sail",
    "map_clauses.sail",
    "event_clauses.sail",
    "decode_end.sail"
  ],
  "slice": { "roots": ["__DecodeExecute", "__FetchInstr"] },
  "mutrecs": ["AArch64_TakeException", "AArch32_SecondStageTranslate", "AArch64_SecondStageTranslate"],
  "cap_typs": ["Capability"],
  "privileged_regs": ["VBAR_EL1", "VBAR_EL2", "VBAR_EL3"],
  "pcc": ["PCC"],
  "idc": ["_R29"],
  "overrides": {
    "AArch64_TakeException": {
      "exp_fails": {
        "proof": "(auto elim!: Run_bindE)"
      },
      "runs_no_reg_writes_to": {
        "proof": "(auto simp: runs_no_reg_writes_to_def)"
      }
    },
    "AArch64_ExceptionReturnToCapability": {
      "traces_enabled": {
        "assms": ["arg0 \\<in> derivable_caps s"],
        "proof": "(traces_enabledI assms: assms intro: derivable_enabled_branch_target)"
      }
    },
    "ConstrainUnpredictable": {
      "non_cap_exp": {
        "proof": "(cases arg0; simp; non_cap_expI)"
      },
      "no_reg_writes_to": {
        "proof": "(cases arg0; simp; no_reg_writes_toI simp: register_defs)"
      }
    },
    "FPRoundBase": {
      "runs_no_reg_writes_to": {
        "proof": "- (* TODO *)"
      }
    },
    "CapabilityFromData": {
      "derivable_caps": {
        "stmts": ["Run (CapabilityFromData n arg1 arg2) t c \\<Longrightarrow> n = 128 \\<Longrightarrow> Capability_of_tag_word (arg1 !! 0) arg2 \\<in> derivable_caps s \\<Longrightarrow> c \\<in> derivable_caps s"],
        "proof": "(auto simp: CapabilityFromData_def)"
      }
    },
    "CheckCapability": {
      "traces_enabled": {
        "assms": [],
        "proof": "(traces_enabledI)"
      }
    },
    "CapSetValue": {
      "derivable_caps": {
        "stmts": ["Run (CapSetValue arg0 arg1) t c \\<Longrightarrow> arg0 \\<in> derivable_caps s \\<Longrightarrow> CapIsTagSet arg0 \\<longrightarrow> \\<not>CapIsSealed arg0 \\<Longrightarrow> c \\<in> derivable_caps s"],
        "proof": "(non_cap_exp_insert_run s, unfold CapSetValue_def, derivable_capsI elim: update_subrange_addr_CapIsRepresentable_derivable intro: update_subrange_if_derivable update_subrange_addr_CapWithTagClear_derivable)"
      }
    },
    "CapAdd": {
      "derivable_caps": {
        "stmts": ["Run (CapAdd arg0 arg1) t c \\<Longrightarrow> arg0 \\<in> derivable_caps s \\<Longrightarrow> CapIsTagSet arg0 \\<longrightarrow> \\<not>CapIsSealed arg0 \\<Longrightarrow> c \\<in> derivable_caps s"],
        "proof": "(non_cap_exp_insert_run s, unfold CapAdd_def, derivable_capsI elim: update_subrange_addr_CapIsRepresentableFast_derivable)"
      }
    },
    "CapAdd__1": {
      "derivable_caps": {
        "stmts": ["Run (CapAdd__1 arg0 arg1) t c \\<Longrightarrow> arg0 \\<in> derivable_caps s \\<Longrightarrow> CapIsTagSet arg0 \\<longrightarrow> \\<not>CapIsSealed arg0 \\<Longrightarrow> c \\<in> derivable_caps s"]
      }
    },
    "CapSetOffset": {
      "derivable_caps": {
        "stmts": ["Run (CapSetOffset arg0 arg1) t c \\<Longrightarrow> arg0 \\<in> derivable_caps s \\<Longrightarrow> CapIsTagSet arg0 \\<longrightarrow> \\<not>CapIsSealed arg0 \\<Longrightarrow> c \\<in> derivable_caps s"],
        "proof": "(non_cap_exp_insert_run s, unfold CapSetOffset_def, derivable_capsI)"
      }
    },
    "CapSetBounds": {
      "derivable_caps": {
        "stmts": ["Run (CapSetBounds arg0 arg1 arg2) t c \\<Longrightarrow> arg0 \\<in> derivable_caps s \\<Longrightarrow> CapIsTagSet arg0 \\<longrightarrow> \\<not>CapIsSealed arg0 \\<Longrightarrow> c \\<in> derivable_caps s"],
        "proof": "- (* TODO *)"
      }
    },
    "X_set": {
      "traces_enabled": {
        "assms": ["LENGTH('a) \\<in> {32, 64}"],
        "stmts": ["traces_enabled (X_set arg0 arg1 (arg2 :: 'a::len word)) s"],
        "proof": "(traces_enabledI assms: assms)"
      }
    },
    "SP_set": {
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "LENGTH('a) \\<in> {32, 64}"],
        "stmts": ["traces_enabled (SP_set arg0 (arg1 :: 'a::len word)) s"],
        "proof": "(traces_enabledI assms: assms)"
      }
    },
    "BaseReg_set": {
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "VA_derivable arg1 s"]
      }
    },
    "BranchXToCapability": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms intro: enabled_branch_target_set_0th derivable_enabled_branch_target)"
      }
    },
    "execute_aarch64_instrs_system_register_cpsr": {
      "non_cap_exp": {
        "proof": "(cases arg0; simp; non_cap_expI)"
      },
      "no_reg_writes_to": {
        "proof": "(cases arg0; simp; no_reg_writes_toI simp: register_defs)"
      }
    },
    "ReduceCombine": {
      "traces_enabled": {
        "unfolding": [],
        "proof": "(cases arg0; simp; traces_enabledI assms: assms)"
      },
      "non_mem_exp": {
        "proof": "(cases arg0; simp; non_mem_expI)"
      },
      "runs_no_reg_writes_to": {
        "proof": "(cases arg0; simp; no_reg_writes_toI simp: register_defs)"
      }
    },
    "Reduce": {
      "traces_enabled": {
        "assms": ["arg2 \\<in> {16, 32, 64}", "nat arg2 \\<le> size arg1", "LENGTH('esize) = nat arg2"],
        "stmts": ["traces_enabled (Reduce arg0 arg1 arg2 :: 'esize::len word M) s"]
      }
    },
    "execute_aarch64_instrs_system_hints": {
      "traces_enabled": {
        "unfolding": [],
        "proof": "(cases arg0; simp; traces_enabledI)"
      },
      "non_mem_exp": {
        "proof": "(cases arg0; simp; non_mem_expI)"
      }
    },
    "AArch64_MemSingle_read": {
      "traces_enabled": {
        "assms": [],
        "proof": "(traces_enabledI)"
      },
      "traces_enabled_mem": {
        "assms": ["translate_address (unat arg0) \\<noteq> None \\<longrightarrow> load_enabled s (unat arg0) arg1 False"],
        "unfolding": ["AArch64_MemSingle_read_def", "AArch64_TranslateAddress_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else IsFault_def translate_correct)"
      }
    },
    "AArch64_MemSingle_set": {
      "traces_enabled": {
        "assms": [],
        "proof": "(traces_enabledI)"
      },
      "traces_enabled_mem": {
        "assms": ["translate_address (unat arg0) \\<noteq> None \\<longrightarrow> store_enabled s (unat arg0) arg1 arg4 False", "LENGTH('a) = 8 * nat arg1"],
        "stmts": ["traces_enabled (AArch64_MemSingle_set arg0 arg1 arg2 arg3 (arg4 :: 'a::len word)) s"],
        "unfolding": ["AArch64_MemSingle_set_def", "AArch64_TranslateAddress_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else IsFault_def translate_correct translate_address_aligned32_plus16)"
      }
    },
    "AArch64_TaggedMemSingle": {
      "derivable_caps": {
        "assms": ["Run (AArch64_TaggedMemSingle addr sz acctype wasaligned) t a", "LENGTH('a) = nat sz * 8"],
        "stmts": ["Capability_of_tag_word (vec_of_bits [access_vec_dec (fst a) 0] !! 0) (slice (snd a :: 'a::len word) 0 128) \\<in> derivable_caps (run s t)"],
        "using": ["assms"],
        "unfolding": ["AArch64_TaggedMemSingle_def"],
        "proof": "(auto simp: test_bit_of_bl elim!: Run_bindE Run_ifE ReadTaggedMem_lower_derivable[THEN derivable_caps_run_imp])"
      },
      "traces_enabled": {
        "assms": [],
        "proof": "(traces_enabledI)"
      },
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) (nat arg1)", "load_enabled s (unat arg0) 16 True", "arg1 = 32 \\<Longrightarrow> load_enabled s (unat arg0 + 16) 16 True", "arg1 = 32 \\<Longrightarrow> load_enabled s (unat arg0) 32 False"],
        "unfolding": ["AArch64_TaggedMemSingle_def", "AArch64_TranslateAddress_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else IsFault_def translate_correct translate_address_aligned32_plus16)"
      }
    },
    "AArch64_TaggedMemSingle__1": {
      "traces_enabled": {
        "assms": ["Capability_of_tag_word (tags !! 0) (ucast data) \\<in> derivable_caps s", "sz = 32 \\<Longrightarrow> Capability_of_tag_word (tags !! 1) (Word.slice 128 data) \\<in> derivable_caps s"],
        "stmts": ["traces_enabled (AArch64_TaggedMemSingle__1 addr sz acctype wasaligned (tags :: 't::len word) (data :: 'd::len word)) s"],
        "proof": "(traces_enabledI assms: assms)"
      },
      "traces_enabled_mem": {
        "assms": ["aligned (unat addr) (nat sz)", "store_enabled s (unat addr) 16 (ucast data :: 128 word) (tags !! 0)", "sz = 32 \\<Longrightarrow> store_enabled s (unat addr + 16) 16 (Word.slice 128 data :: 128 word) (tags !! 1)", "LENGTH('t) = nat sz div 16", "LENGTH('d) = 8 * nat sz"],
        "stmts": ["traces_enabled (AArch64_TaggedMemSingle__1 addr sz acctype wasaligned (tags :: 't::len word) (data :: 'd::len word)) s"],
        "proof": "(traces_enabledI assms: assms intro: access_enabled_runI simp: exp_fails_if_then_else IsFault_def translate_correct translate_address_aligned32_plus16)"
      }
    },
    "AArch64_CapabilityTag": {
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 16 \\<longrightarrow> load_enabled s (unat arg0) 16 True"],
        "unfolding": ["AArch64_CapabilityTag_def", "AArch64_TranslateAddress_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms intro: access_enabled_runI simp: exp_fails_if_then_else IsFault_def translate_correct trace_assms_def ev_assms_def load_enabled_def)"
      }
    },
    "AArch64_CapabilityTag_set": {
      "traces_enabled": {
        "assms": ["arg2 = 0"],
        "proof": "(traces_enabledI assms: assms)"
      },
      "traces_enabled_mem": {
        "assms": ["\\<And>data :: 128 word. aligned (unat vaddr) 16 \\<longrightarrow> store_enabled s (unat vaddr) 16 data False", "tag = 0"],
        "stmts": ["traces_enabled (AArch64_CapabilityTag_set vaddr acctype tag) s"],
        "unfolding": ["AArch64_CapabilityTag_set_def", "AArch64_TranslateAddress_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else IsFault_def translate_correct)"
      }
    },
    "_WriteTags": {
      "traces_enabled_mem": {
        "assms": ["\\<And>data :: 128 word. access_enabled s Store (unat (FullAddress_address (AddressDescriptor_paddress desc))) 16 (mem_bytes_of_word data) B0", "n = 1", "tags = 0"],
        "stmts": ["traces_enabled (WriteTags desc sz tags addrdesc) s"],
        "unfolding": ["WriteTags_def", "bind_assoc"]
      }
    },
    "Mem_read": {
      "traces_enabled": {
        "assms": [],
        "proof": "(traces_enabledI)"
      },
      "traces_enabled_mem": {
        "assms": ["load_enabled s (unat vaddr) sz False"],
        "stmts": ["traces_enabled (Mem_read0 vaddr sz acctype) s"],
        "proof": "(traces_enabledI assms: assms simp: AArch64_MemSingle_read_translate_address_Some)"
      }
    },
    "Mem_set": {
      "traces_enabled": {
        "assms": [],
        "proof": "(traces_enabledI)"
      },
      "traces_enabled_mem": {
        "assms": ["store_enabled s (unat vaddr) sz data False", "LENGTH('a) = 8 * nat sz"],
        "stmts": ["traces_enabled (Mem_set0 vaddr sz acctype (data :: 'a::len word)) s"],
        "proof": "(traces_enabledI assms: assms simp: AArch64_MemSingle_set_translate_address_Some)"
      }
    },
    "MemC_read": {
      "derivable_caps": {
        "stmts": ["Run (MemC_read arg0 arg1) t c \\<Longrightarrow> use_mem_caps \\<Longrightarrow> c \\<in> derivable_caps (run s t)"]
      },
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 16 \\<longrightarrow> load_enabled s (unat arg0) 16 True"],
        "proof": "(traces_enabledI assms: assms)"
      }
    },
    "MemC_set": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms simp: update_subrange_vec_dec_test_bit)"
      },
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 16 \\<longrightarrow> store_enabled s (unat arg0) 16 (ucast arg2 :: 128 word) (CapIsTagSet arg2)"],
        "proof": "(traces_enabledI assms: assms simp: update_subrange_vec_dec_test_bit)"
      }
    },
    "MemCP": {
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 32", "load_enabled s (unat arg0) arg1 16 True", "load_enabled s (unat arg0 + 16) arg1 16 True", "load_enabled s (unat arg0) arg1 32 False"],
        "proof": "(traces_enabledI assms: assms)"
      }
    },
    "MemCP__1": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms simp: update_subrange_vec_dec_test_bit update_subrange_vec_dec_word_cat_cap_pair slice_128_cat_cap_pair)"
      },
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 32", "store_enabled s (unat arg0) 16 (ucast arg2 :: 128 word) (CapIsTagSet arg2)", "store_enabled s (unat arg0 + 16) 16 (ucast arg3 :: 128 word) (CapIsTagSet arg3)"],
        "proof": "(traces_enabledI assms: assms simp: DataFromCapability_def update_subrange_vec_dec_test_bit update_subrange_vec_dec_word_cat_cap_pair slice_128_cat_cap_pair)"
      }
    },
    "MemAtomicC": {
      "derivable_caps": {
        "assms": ["Run (MemAtomicC arg0 arg1 arg2 arg3 arg4) t c", "arg2 \\<in> derivable_caps s", "use_mem_caps"],
        "stmts": ["c \\<in> derivable_caps (run s t)"],
        "using": ["assms(1)"],
        "unfolding": ["MemAtomicC_def"],
        "proof": "- (derivable_capsI assms: assms(2) intro: assms(3))"
      },
      "traces_enabled": {
        "assms": ["arg2 \\<in> derivable_caps s"],
        "proof": "(traces_enabledI assms: assms simp: update_subrange_vec_dec_test_bit)"
      },
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 16 \\<longrightarrow> load_enabled s (unat arg0) 16 True", "aligned (unat arg0) 16 \\<longrightarrow> store_enabled s (unat arg0) 16 (ucast arg2 :: 128 word) (CapIsTagSet arg2)", "arg2 \\<in> derivable_caps s"],
        "unfolding": ["MemAtomicC_def", "AArch64_TranslateAddressForAtomicAccess_def", "AArch64_TranslateAddress_def", "Let_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: DataFromCapability_def update_subrange_vec_dec_test_bit test_bit_of_bl exp_fails_if_then_else IsFault_def translate_correct)"
      }
    },
    "MemAtomicCompareAndSwap": {
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s"]
      },
      "traces_enabled_mem": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "VA_derivable base s", "8 dvd LENGTH('a)"],
        "stmts": ["traces_enabled (MemAtomicCompareAndSwap base expval (newval :: 'a::len word) ldacctype stacctype) s"],
        "unfolding": ["MemAtomicCompareAndSwap_def", "AArch64_TranslateAddressForAtomicAccess_def", "AArch64_TranslateAddress_def", "Let_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else IsFault_def translate_correct)"
      }
    },
    "MemAtomicCompareAndSwapC": {
      "derivable_caps": {
        "assms": ["Run (MemAtomicCompareAndSwapC arg0 arg1 arg2 arg3 arg4 arg5) t c", "arg2 \\<in> derivable_caps s", "arg3 \\<in> derivable_caps s", "{''PCC''} \\<subseteq> accessible_regs s", "use_mem_caps"],
        "stmts": ["c \\<in> derivable_caps (run s t)"],
        "using": ["assms(1)"],
        "unfolding": ["MemAtomicCompareAndSwapC_def"],
        "proof": "- (derivable_capsI assms: assms(2-4) intro: assms(5))"
      },
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "arg2 \\<in> derivable_caps s", "arg3 \\<in> derivable_caps s"],
        "proof": "(traces_enabledI assms: assms simp: update_subrange_vec_dec_test_bit)"
      },
      "traces_enabled_mem": {
        "assms": ["aligned (unat addr) 16 \\<longrightarrow> load_enabled s (unat addr) 16 True", "aligned (unat addr) 16 \\<longrightarrow> store_enabled s (unat addr) 16 (ucast newcap :: 128 word) (CapIsTagSet newcap)", "newcap \\<in> derivable_caps s"],
        "stmts": ["traces_enabled (MemAtomicCompareAndSwapC va addr expcap newcap ldacctype stacctype) s"],
        "unfolding": ["MemAtomicCompareAndSwapC_def", "AArch64_TranslateAddressForAtomicAccess_def", "AArch64_TranslateAddress_def", "Let_def bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else IsFault_def translate_correct update_subrange_vec_dec_test_bit)"
      }
    },
    "MemAtomic": {
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s"]
      },
      "traces_enabled_mem": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "VA_derivable base s", "8 dvd LENGTH('a)"],
        "stmts": ["traces_enabled (MemAtomic base op (data :: 'a::len word) ldacctype stacctype) s"],
        "unfolding": ["MemAtomic_def", "AArch64_TranslateAddressForAtomicAccess_def", "AArch64_TranslateAddress_def", "Let_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else IsFault_def translate_correct)"
      }
    },
    "AArch64_AutoGen_ArchitectureReset": {
      "traces_enabled": {
        "unfolding": [],
        "proof": "- (* TODO: takes very long *)"
      },
      "no_reg_writes_to": {
        "proof": "- (* TODO: takes very long *)"
      }
    },
    "AArch64_IMPDEFResets": {
      "no_reg_writes_to": {
        "proof": "- (* TODO: takes very long *)"
      }
    },
    "AArch64_AutoGen_SysRegRead": {
      "traces_enabled": {
        "unfolding": [],
        "proof": "- (* TODO: takes very long *)"
      }
    },
    "AArch64_AutoGen_SysRegWrite": {
      "traces_enabled": {
        "unfolding": [],
        "proof": "- (* TODO: takes very long *)"
      },
      "runs_no_reg_writes_to": {
        "proof": "- (* TODO: takes very long *)"
      }
    },
    "CAP_DC_CVAU": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms intro: traces_enabled_bind)"
      }
    },
    "CAP_IC_IVAU": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms intro: traces_enabled_bind)"
      }
    },
    "VAToCapability": {
      "derivable_caps": {
        "stmts": ["Run (VAToCapability va) t c \\<Longrightarrow> VA_derivable va s \\<Longrightarrow> c \\<in> derivable_caps s"],
        "proof": "(auto simp: VA_derivable_def)"
      }
    },
    "execute_STLXP_R_CR_C": {
      "traces_enabled_mem": {
        "proof": "(traces_enabledI assms: assms elim: VADeref_store_enabled)"
      }
    },
    "execute_BLRS_C_C_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms intro: enabled_branch_targetI[where c = \"CapUnseal c\" for c] elim: branch_sealed_pair_enabled_pcc branch_sealed_pair_C_set_29)"
      }
    },
    "execute_BRS_C_C_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms intro: enabled_branch_targetI[where c = \"CapUnseal c\" for c] elim: branch_sealed_pair_enabled_pcc branch_sealed_pair_C_set_29)"
      }
    },
    "execute_RETS_C_C_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms intro: enabled_branch_targetI[where c = \"CapUnseal c\" for c] elim: branch_sealed_pair_enabled_pcc branch_sealed_pair_C_set_29)"
      }
    },
    "execute_STXP_R_CR_C": {
      "traces_enabled_mem": {
        "proof": "(traces_enabledI assms: assms elim: VADeref_store_enabled)"
      }
    },
    "execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms elim: Run_case_MemOp_LOAD_STORE_not_VAIsSealedCap_generic)"
      }
    },
    "execute_aarch64_instrs_memory_vector_single_no_wb": {
      "traces_enabled_mem": {
        "proof": "(traces_enabledI assms: assms intro: traces_enabled_foreachM_index_list_inv[where Inv = \"\\<lambda>idx (element, offset :: 64 word, t) s. offset = word_of_int (idx * size_itself_int arg1 div 8)\"] traces_enabled_foreachM_index_list_inv[where Inv = \"\\<lambda>idx (offset :: 64 word, rval, t) s. offset = word_of_int (idx * size_itself_int arg1 div 8)\"] simp: Run_bind_iff Run_if_iff wi_hom_syms)"
      }
    },
    "execute_aarch64_instrs_memory_exclusive_pair": {
      "traces_enabled_mem": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "LENGTH('regsize) \\<in> {32, 64} \\<and> arg2 \\<in> {32, 64} \\<and> arg1 = 2 * arg2"],
        "stmts": ["traces_enabled (execute_aarch64_instrs_memory_exclusive_pair arg0 arg1 arg2 arg3 arg4 True (arg6 :: 'regsize::len itself) arg7 arg8 arg9) s"]
      }
    },
    "execute_aarch64_instrs_memory_exclusive_single": {
      "traces_enabled_mem": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "LENGTH('regsize) \\<in> {32, 64} \\<and> arg2 \\<in> {8, 16, 32, 64} \\<and> arg1 = arg2"],
        "stmts": ["traces_enabled (execute_aarch64_instrs_memory_exclusive_single arg0 arg1 arg2 arg3 arg4 False (arg6 :: 'regsize::len itself) arg7 arg8 arg9) s"]
      }
    },
    "execute_aarch64_instrs_memory_vector_multiple_no_wb": {
      "traces_enabled_mem": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "arg1 > 0 \\<and> arg6 > 0 \\<and> arg7 > 0 \\<and> LENGTH('esize) \\<ge> 8 \\<and> 8 dvd LENGTH('esize)"],
        "proof": "- (* TODO: traces_enabledI assms: assms intro: traces_enabled_foreachM_index_list_inv[where to = \"arg6 - 1\" and Inv = \"\\<lambda>idx (offset, _, _) _. unat offset = nat idx * nat arg1 * nat arg7 * (size_itself arg2 div 8)\"] traces_enabled_foreachM_index_list_inv[where to = \"arg1 - 1\" and vars = vars0 and Inv = \"\\<lambda>idx (offset, _, _) _. case vars0 of (offset0, _, _) \\<Rightarrow> unat offset = unat offset0 + nat idx * nat arg7 * (size_itself arg2 div 8)\" for vars0] traces_enabled_foreachM_index_list_inv[where to = \"arg7 - 1\" and vars = vars0 and Inv = \"\\<lambda>idx (offset, _, _) _. case vars0 of (offset0, _, _) \\<Rightarrow> unat offset = unat offset0 + nat idx * (size_itself arg2 div 8)\" for vars0] *)"
      }
    },
    "execute_aarch64_instrs_memory_pair_simdfp_no_alloc": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('datasize) \\<in> {32, 64, 128, 256}", "\\<not>arg5", "\\<not>arg8"]
      }
    },
    "execute_aarch64_instrs_memory_pair_general_no_alloc": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('datasize) \\<in> {32, 64}", "\\<not>arg8"]
      }
    },
    "execute_aarch64_instrs_memory_pair_simdfp_post_idx": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('datasize) \\<in> {32, 64, 128, 256}", "arg2 \\<noteq> MemOp_PREFETCH"]
      }
    },
    "execute_aarch64_instrs_memory_pair_general_post_idx": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('datasize) \\<in> {32, 64}", "arg2 \\<noteq> MemOp_PREFETCH"]
      }
    },
    "execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('datasize) \\<in> {8, 16, 32, 64, 128, 256, 512, 1024}", "arg2 \\<noteq> MemOp_PREFETCH"]
      }
    },
    "execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('regsize) \\<in> {32, 64}", "int LENGTH('datasize) \\<in> {8, 16, 32, 64}", "arg2 \\<noteq> MemOp_PREFETCH"]
      }
    },
    "execute_aarch64_instrs_memory_single_simdfp_register": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "arg7 \\<in> {0, 1, 2, 3, 4, 5, 6, 7}", "int LENGTH('datasize) \\<in> {8, 16, 32, 64, 128, 256, 512, 1024}", "arg4 \\<noteq> MemOp_PREFETCH"]
      }
    },
    "execute_aarch64_instrs_memory_single_general_register": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "arg8 \\<in> {0, 1, 2, 3}", "int LENGTH('regsize) \\<in> {32, 64}", "int LENGTH('datasize) \\<in> {8, 16, 32, 64}", "\\<not>arg11"]
      }
    },
    "execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('regsize) \\<in> {32, 64}", "int LENGTH('datasize) \\<in> {8, 16, 32, 64}", "\\<not>arg8"]
      }
    },
    "execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('datasize) \\<in> {8, 16, 32, 64, 128, 256, 512, 1024}", "\\<not>arg7"]
      }
    },
    "execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('regsize) \\<in> {32, 64}", "int LENGTH('datasize) \\<in> {8, 16, 32, 64}", "\\<not>arg9"]
      }
    },
    "execute_aarch64_instrs_memory_single_general_immediate_unsigned": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('regsize) \\<in> {32, 64}", "int LENGTH('datasize) \\<in> {8, 16, 32, 64}", "\\<not>arg9"]
      }
    },
    "execute_LDCT_R_R__": {
      "traces_enabled_mem": {
        "proof": "(traces_enabledI assms: assms intro: traces_enabled_foreachM_index_list_inv[where Inv = \"\\<lambda>idx (addr, _) s. case vars0 of (addr0, _) \\<Rightarrow> addr = addr0 + word_of_int (idx * 16)\" and vars = vars0 for vars0] simp: wi_hom_syms)"
      }
    },
    "execute_BUILD_C_C_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms elim: CapIsSubSetOf_WithTagSet_derivable Run_or_boolM_E Run_bindE simp: CapIsBaseAboveLimit_get_base_leq_get_limit)"
      }
    },
    "execute_CHKSSU_C_CC_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms elim: CapIsSubSetOf_CapUnseal_derivable Run_and_boolM_E)"
      }
    },
    "execute_CSEAL_C_C_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms elim: Run_and_boolM_E CapIsInBounds_cursor_in_mem_region)"
      }
    },
    "execute_SEAL_C_CC_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms simp: Run_and_boolM_True_iff elim: CapIsInBounds_cursor_in_mem_region)"
      }
    },
    "execute_SEAL_C_CI_C": {
      "traces_enabled": {
        "assms": ["{''_R29''} \\<subseteq> accessible_regs s", "arg1 \\<in> {0, 1, 2, 3}"],
        "proof": "(traces_enabledI assms: assms intro: CapSetObjectType_sentry_derivable)"
      }
    },
    "decode_SEAL_C_CI_C": {
      "traces_enabled": {
        "proof": "(cases arg0 rule: exhaustive_2_word) (use assms in \\<open>auto intro: traces_enabled_execute_SEAL_C_CI_C\\<close>)"
      }
    },
    "execute_UNSEAL_C_CC_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms intro: CapUnseal_check_global_derivable simp: Run_and_boolM_True_iff)"
      }
    },
    "execute_SCTAG_C_CR_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms simp: Run_and_boolM_True_iff IsTagSettingDisabled_not_False)"
      }
    },
    "execute_STCT_R_R__": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms simp: Run_and_boolM_True_iff IsTagSettingDisabled_not_False)"
      }
    }
  },
  "invoked_regs": {
    "execute_BLRR_C_C": ["arg1"],
    "decode_BLRR_C_C": ["uint arg1"],
    "execute_BLRS_C_C": ["arg1"],
    "decode_BLRS_C_C": ["uint arg1"],
    "execute_BLRS_C_C_C": ["arg1", "arg2"],
    "decode_BLRS_C_C_C": ["uint arg0", "uint arg2"],
    "execute_BLR_C_C": ["arg1"],
    "decode_BLR_C_C": ["uint arg1"],
    "execute_BRR_C_C": ["arg1"],
    "decode_BRR_C_C": ["uint arg1"],
    "execute_BRS_C_C": ["arg1"],
    "decode_BRS_C_C": ["uint arg1"],
    "execute_BRS_C_C_C": ["arg1", "arg2"],
    "decode_BRS_C_C_C": ["uint arg0", "uint arg2"],
    "execute_BR_C_C": ["arg1"],
    "decode_BR_C_C": ["uint arg1"],
    "execute_RETR_C_C": ["arg1"],
    "decode_RETR_C_C": ["uint arg1"],
    "execute_RETS_C_C": ["arg1"],
    "decode_RETS_C_C": ["uint arg1"],
    "execute_RETS_C_C_C": ["arg1", "arg2"],
    "decode_RETS_C_C_C": ["uint arg0", "uint arg2"],
    "execute_RET_C_C": ["arg1"],
    "decode_RET_C_C": ["uint arg1"]
  },
  "invokes_mem_caps": [
    "execute_BLR_CI_C",
    "decode_BLR_CI_C",
    "execute_BR_CI_C",
    "decode_BR_CI_C",
    "execute_LDPBLR_C_C_C",
    "decode_LDPBLR_C_C_C",
    "execute_LDPBR_C_C_C",
    "decode_LDPBR_C_C_C"
  ],
  "cap_load_funs": ["_ReadTaggedMem"],
  "skips": [
    "__ReadRAM",
    "__WriteRAM",
    "_Mem_read",
    "_Mem_set",
    "_ReadMem",
    "_ReadTaggedMem",
    "_ReadTags",
    "_WriteMem",
    "_WriteTaggedMem",
    "_WriteTags"
  ]
}
