{
  "name": "Morello",
  "files": [
    "prelude.sail",
    "builtins.sail",
    "decode_start.sail",
    "v8_base.sail",
    "v8post.sail",
    "version.sail",
    "config.sail",
    "config_list.sail",
    "events.sail",
    "interrupts.sail",
    "fetch.sail",
    "mem.sail",
    "reset.sail",
    "semihost.sail",
    "v8debug.sail",
    "counters.sail",
    "instrs.sail",
    "map_clauses.sail",
    "event_clauses.sail",
    "decode_end.sail"
  ],
  "slice": { "roots": ["__DecodeExecute", "__FetchInstr"] },
  "mutrecs": ["AArch64_TakeException", "AArch32_SecondStageTranslate", "AArch64_SecondStageTranslate"],
  "cap_typs": ["Capability"],
  "privileged_regs": ["CVBAR_EL1", "CVBAR_EL2", "CVBAR_EL3"],
  "pcc": ["PCC"],
  "idc": ["_R29"],
  "overrides": {
    "C_read": {
      "derivable_caps": {
        "proof": "(auto elim!: Run_bindE Run_ifE derivable_capsE)"
      }
    },
    "AArch64_TakeException": {
      "exp_fails": {
        "proof": "(auto elim!: Run_bindE)"
      },
      "runs_no_reg_writes_to": {
        "proof": "(auto simp: runs_no_reg_writes_to_def)"
      }
    },
    "ConstrainUnpredictable": {
      "non_cap_exp": {
        "proof": "(cases arg0; simp; non_cap_expI)"
      },
      "no_reg_writes_to": {
        "proof": "(cases arg0; simp; no_reg_writes_toI simp: register_defs)"
      }
    },
    "execute_aarch64_instrs_system_register_cpsr": {
      "non_cap_exp": {
        "proof": "(cases arg0; simp; non_cap_expI)"
      },
      "no_reg_writes_to": {
        "proof": "(cases arg0; simp; no_reg_writes_toI simp: register_defs)"
      }
    },
    "ReduceCombine": {
      "non_mem_exp": {
        "proof": "(cases arg0; simp; non_mem_expI)"
      },
      "runs_no_reg_writes_to": {
        "proof": "(cases arg0; simp; no_reg_writes_toI simp: register_defs)"
      }
    },
    "execute_aarch64_instrs_system_hints": {
      "non_mem_exp": {
        "proof": "(cases arg0; simp; non_mem_expI)"
      }
    },
    "AArch64_MemSingle_read": {
      "traces_enabled_mem": {
        "assms": ["translate_address (unat arg0) \\<noteq> None \\<longrightarrow> load_enabled s (unat arg0) arg1 False"],
        "unfolding": ["AArch64_MemSingle_read_def", "AArch64_TranslateAddress_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else IsFault_def translate_correct)"
      }
    },
    "AArch64_MemSingle_set": {
      "traces_enabled_mem": {
        "assms": ["translate_address (unat arg0) \\<noteq> None \\<longrightarrow> store_enabled s (unat arg0) arg1 arg4 False", "LENGTH('a) = 8 * nat arg1"],
        "stmts": ["traces_enabled (AArch64_MemSingle_set arg0 arg1 arg2 arg3 (arg4 :: 'a::len word)) s"],
        "unfolding": ["AArch64_MemSingle_set_def", "AArch64_TranslateAddress_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else IsFault_def translate_correct translate_address_aligned32_plus16)"
      }
    },
    "AArch64_TaggedMemSingle": {
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) (nat arg1)", "load_enabled s (unat arg0) 16 True", "arg1 = 32 \\<Longrightarrow> load_enabled s (unat arg0 + 16) 16 True", "arg1 = 32 \\<Longrightarrow> load_enabled s (unat arg0) 32 False"],
        "unfolding": ["AArch64_TaggedMemSingle_def", "AArch64_TranslateAddress_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else IsFault_def translate_correct translate_address_aligned32_plus16)"
      }
    },
    "AArch64_TaggedMemSingle__1": {
      "traces_enabled_mem": {
        "assms": ["aligned (unat addr) (nat sz)", "store_enabled s (unat addr) 16 (ucast data :: 128 word) (tags !! 0)", "Capability_of_tag_word (tags !! 0) (ucast data) \\<in> derivable_caps s", "sz = 32 \\<Longrightarrow> Capability_of_tag_word (tags !! 1) (Word.slice 128 data) \\<in> derivable_caps s", "sz = 32 \\<Longrightarrow> store_enabled s (unat addr + 16) 16 (Word.slice 128 data :: 128 word) (tags !! 1)", "LENGTH('t) = nat sz div 16", "LENGTH('d) = 8 * nat sz"],
        "stmts": ["traces_enabled (AArch64_TaggedMemSingle__1 addr sz acctype wasaligned (tags :: 't::len word) (data :: 'd::len word)) s"],
        "unfolding": ["AArch64_TaggedMemSingle__1_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms intro: access_enabled_runI simp: exp_fails_if_then_else IsFault_def translate_correct translate_address_aligned32_plus16)"
      }
    },
    "AArch64_CapabilityTag": {
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 16 \\<longrightarrow> load_enabled s (unat arg0) 16 True"],
        "unfolding": ["AArch64_CapabilityTag_def", "AArch64_TranslateAddress_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms intro: access_enabled_runI simp: exp_fails_if_then_else IsFault_def translate_correct trace_assms_def ev_assms_def load_enabled_def)"
      }
    },
    "AArch64_CapabilityTag_set": {
      "traces_enabled_mem": {
        "assms": ["\\<And>data :: 128 word. aligned (unat vaddr) 16 \\<longrightarrow> store_enabled s (unat vaddr) 16 data False", "tag = 0"],
        "stmts": ["traces_enabled (AArch64_CapabilityTag_set vaddr acctype tag) s"],
        "unfolding": ["AArch64_CapabilityTag_set_def", "AArch64_TranslateAddress_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else IsFault_def translate_correct)"
      }
    },
    "_WriteTags": {
      "traces_enabled_mem": {
        "assms": ["\\<And>data :: 128 word. access_enabled s Store (unat (FullAddress_address (AddressDescriptor_paddress desc))) 16 (mem_bytes_of_word data) B0", "n = 1", "tags = 0"],
        "stmts": ["traces_enabled (WriteTags desc sz tags addrdesc) s"],
        "unfolding": ["WriteTags_def", "bind_assoc"]
      }
    },
    "Mem_read": {
      "traces_enabled_mem": {
        "assms": ["load_enabled s (unat vaddr) sz False"],
        "stmts": ["traces_enabled (Mem_read0 vaddr sz acctype) s"],
        "proof": "(traces_enabledI assms: assms simp: AArch64_MemSingle_read_translate_address_Some)"
      }
    },
    "Mem_set": {
      "traces_enabled_mem": {
        "assms": ["store_enabled s (unat vaddr) sz data False", "LENGTH('a) = 8 * nat sz"],
        "stmts": ["traces_enabled (Mem_set0 vaddr sz acctype (data :: 'a::len word)) s"],
        "proof": "(traces_enabledI assms: assms simp: AArch64_MemSingle_set_translate_address_Some)"
      }
    },
    "MemC_read": {
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 16 \\<longrightarrow> load_enabled s (unat arg0) 16 True"],
        "proof": "(traces_enabledI assms: assms)"
      }
    },
    "MemC_set": {
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 16 \\<longrightarrow> store_enabled s (unat arg0) 16 (ucast arg2 :: 128 word) (CapIsTagSet arg2)", "arg2 \\<in> derivable_caps s"],
        "proof": "(traces_enabledI assms: assms simp: DataFromCapability_def update_subrange_vec_dec_test_bit)"
      }
    },
    "MemCP": {
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 32", "load_enabled s (unat arg0) arg1 16 True", "load_enabled s (unat arg0 + 16) arg1 16 True", "load_enabled s (unat arg0) arg1 32 False"],
        "proof": "(traces_enabledI assms: assms)"
      }
    },
    "MemCP__1": {
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 32", "store_enabled s (unat arg0) 16 (ucast arg2 :: 128 word) (CapIsTagSet arg2)", "store_enabled s (unat arg0 + 16) 16 (ucast arg3 :: 128 word) (CapIsTagSet arg3)", "arg2 \\<in> derivable_caps s", "arg3 \\<in> derivable_caps s"],
        "proof": "(traces_enabledI assms: assms simp: DataFromCapability_def update_subrange_vec_dec_test_bit update_subrange_vec_dec_word_cat_cap_pair slice_128_cat_cap_pair)"
      }
    },
    "MemAtomicC": {
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 16 \\<longrightarrow> load_enabled s (unat arg0) 16 True", "aligned (unat arg0) 16 \\<longrightarrow> store_enabled s (unat arg0) 16 (ucast arg2 :: 128 word) (CapIsTagSet arg2)", "arg2 \\<in> derivable_caps s"],
        "unfolding": ["MemAtomicC_def", "AArch64_TranslateAddressForAtomicAccess_def", "AArch64_TranslateAddress_def", "Let_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: DataFromCapability_def update_subrange_vec_dec_test_bit test_bit_of_bl exp_fails_if_then_else IsFault_def translate_correct)"
      }
    },
    "MemAtomicCompareAndSwap": {
      "traces_enabled_mem": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "VA_derivable base s", "8 dvd LENGTH('a)"],
        "stmts": ["traces_enabled (MemAtomicCompareAndSwap base expval (newval :: 'a::len word) ldacctype stacctype) s"],
        "unfolding": ["MemAtomicCompareAndSwap_def", "AArch64_TranslateAddressForAtomicAccess_def", "AArch64_TranslateAddress_def", "Let_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else IsFault_def translate_correct)"
      }
    },
    "MemAtomicCompareAndSwapC": {
      "traces_enabled_mem": {
        "assms": ["aligned (unat addr) 16 \\<longrightarrow> load_enabled s (unat addr) 16 True", "aligned (unat addr) 16 \\<longrightarrow> store_enabled s (unat addr) 16 (ucast newcap :: 128 word) (CapIsTagSet newcap)", "newcap \\<in> derivable_caps s"],
        "stmts": ["traces_enabled (MemAtomicCompareAndSwapC va addr expcap newcap ldacctype stacctype) s"],
        "unfolding": ["MemAtomicCompareAndSwapC_def", "AArch64_TranslateAddressForAtomicAccess_def", "AArch64_TranslateAddress_def", "Let_def bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else IsFault_def translate_correct update_subrange_vec_dec_test_bit)"
      }
    },
    "MemAtomic": {
      "traces_enabled_mem": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "VA_derivable base s", "8 dvd LENGTH('a)"],
        "stmts": ["traces_enabled (MemAtomic base op (data :: 'a::len word) ldacctype stacctype) s"],
        "unfolding": ["MemAtomic_def", "AArch64_TranslateAddressForAtomicAccess_def", "AArch64_TranslateAddress_def", "Let_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else IsFault_def translate_correct)"
      }
    },
    "AArch64_AutoGen_ArchitectureReset": {
      "no_reg_writes_to": {
        "proof": "- (* TODO: takes very long *)"
      }
    },
    "AArch64_IMPDEFResets": {
      "no_reg_writes_to": {
        "proof": "- (* TODO: takes very long *)"
      }
    },
    "AArch64_AutoGen_SysRegWrite": {
      "runs_no_reg_writes_to": {
        "proof": "- (* TODO: takes very long *)"
      }
    },
    "DC_ZVA": {
      "traces_enabled_mem": {
        "proof": "- (* needs fixing in ASL *)"
      }
    },
    "VAToCapability": {
      "derivable_caps": {
        "stmts": ["Run (VAToCapability va) t c \\<Longrightarrow> VA_derivable va s \\<Longrightarrow> c \\<in> derivable_caps s"],
        "proof": "(auto simp: VA_derivable_def)"
      }
    },
    "execute_STLXP_R_CR_C": {
      "traces_enabled_mem": {
        "proof": "(traces_enabledI assms: assms elim: VADeref_store_enabled)"
      }
    },
    "execute_STXP_R_CR_C": {
      "traces_enabled_mem": {
        "proof": "(traces_enabledI assms: assms elim: VADeref_store_enabled)"
      }
    },
    "execute_aarch64_instrs_memory_vector_single_no_wb": {
      "traces_enabled_mem": {
        "proof": "(traces_enabledI assms: assms intro: traces_enabled_foreachM_index_list_inv[where Inv = \"\\<lambda>idx (element, offset :: 64 word, t) s. offset = word_of_int (idx * size_itself_int arg1 div 8)\"] traces_enabled_foreachM_index_list_inv[where Inv = \"\\<lambda>idx (offset :: 64 word, rval, t) s. offset = word_of_int (idx * size_itself_int arg1 div 8)\"] simp: Run_bind_iff Run_if_iff wi_hom_syms)"
      }
    },
    "execute_aarch64_instrs_memory_exclusive_pair": {
      "traces_enabled_mem": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "LENGTH('regsize) \\<in> {32, 64} \\<and> arg2 \\<in> {32, 64} \\<and> arg1 = 2 * arg2"],
        "stmts": ["traces_enabled (execute_aarch64_instrs_memory_exclusive_pair arg0 arg1 arg2 arg3 arg4 True (arg6 :: 'regsize::len itself) arg7 arg8 arg9) s"]
      }
    },
    "execute_aarch64_instrs_memory_exclusive_single": {
      "traces_enabled_mem": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "LENGTH('regsize) \\<in> {32, 64} \\<and> arg2 \\<in> {8, 16, 32, 64} \\<and> arg1 = arg2"],
        "stmts": ["traces_enabled (execute_aarch64_instrs_memory_exclusive_single arg0 arg1 arg2 arg3 arg4 False (arg6 :: 'regsize::len itself) arg7 arg8 arg9) s"]
      }
    },
    "execute_aarch64_instrs_memory_vector_multiple_no_wb": {
      "traces_enabled_mem": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "arg1 > 0 \\<and> arg6 > 0 \\<and> arg7 > 0 \\<and> LENGTH('esize) \\<ge> 8 \\<and> 8 dvd LENGTH('esize)"],
        "proof": "- (* TODO: traces_enabledI assms: assms intro: traces_enabled_foreachM_index_list_inv[where to = \"arg6 - 1\" and Inv = \"\\<lambda>idx (offset, _, _) _. unat offset = nat idx * nat arg1 * nat arg7 * (size_itself arg2 div 8)\"] traces_enabled_foreachM_index_list_inv[where to = \"arg1 - 1\" and vars = vars0 and Inv = \"\\<lambda>idx (offset, _, _) _. case vars0 of (offset0, _, _) \\<Rightarrow> unat offset = unat offset0 + nat idx * nat arg7 * (size_itself arg2 div 8)\" for vars0] traces_enabled_foreachM_index_list_inv[where to = \"arg7 - 1\" and vars = vars0 and Inv = \"\\<lambda>idx (offset, _, _) _. case vars0 of (offset0, _, _) \\<Rightarrow> unat offset = unat offset0 + nat idx * (size_itself arg2 div 8)\" for vars0] *)"
      }
    },
    "execute_LDCT_R_R__": {
      "traces_enabled_mem": {
        "proof": "(traces_enabledI assms: assms intro: traces_enabled_foreachM_index_list_inv[where Inv = \"\\<lambda>idx (addr, _) s. case vars0 of (addr0, _) \\<Rightarrow> addr = addr0 + word_of_int (idx * 16)\" and vars = vars0 for vars0] simp: wi_hom_syms)"
      }
    }
  },
  "skips": [
    "__ReadRAM",
    "__WriteRAM",
    "_Mem_read",
    "_Mem_set",
    "_ReadMem",
    "_ReadTaggedMem",
    "_ReadTags",
    "_WriteMem",
    "_WriteTaggedMem",
    "_WriteTags"
  ]
}
