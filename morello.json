{
  "name": "Morello",
  "files": [
    "prelude.sail",
    "builtins.sail",
    "decode_start.sail",
    "v8_base.sail",
    "v8post.sail",
    "version.sail",
    "config.sail",
    "config_list.sail",
    "events.sail",
    "interrupts.sail",
    "fetch.sail",
    "mem.sail",
    "reset.sail",
    "semihost.sail",
    "v8debug.sail",
    "counters.sail",
    "instrs.sail",
    "map_clauses.sail",
    "event_clauses.sail",
    "decode_end.sail"
  ],
  "slice": { "roots": ["__DecodeExecute", "__FetchInstr"] },
  "mutrecs": ["AArch64_TakeException", "AArch32_SecondStageTranslate", "AArch64_SecondStageTranslate"],
  "cap_typs": ["Capability"],
  "privileged_regs": ["CDBGDTR_EL0", "CDLR_EL0", "VBAR_EL1", "VBAR_EL2", "VBAR_EL3"],
  "system_access_checks": ["CapIsSystemAccessEnabled", "Halted"],
  "pcc": ["PCC"],
  "idc": ["_R29"],
  "overrides": {
    "AArch64_TakeException": {
      "exp_fails": {
        "proof": "(auto elim!: Run_bindE)"
      },
      "runs_no_reg_writes_to": {
        "proof": "(auto simp: runs_no_reg_writes_to_def)"
      },
      "traces_enabled": {
	"unfolding": [],
	"proof": "(rule exp_fails_traces_enabled, simp, unfold AArch64_TakeException_def bind_assoc, traces_enabledI assms: assms elim: CapSetValue_exception_target_enabled_branch_target)"
      }
    },
    "AArch64_ExceptionReturnToCapability": {
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "arg0 \\<in> derivable_caps s"],
        "proof": "(traces_enabledI assms: assms intro: derivable_enabled_branch_target)"
      }
    },
    "ConstrainUnpredictable": {
      "non_cap_exp": {
        "proof": "(cases arg0; simp; non_cap_expI)"
      },
      "no_reg_writes_to": {
        "proof": "(cases arg0; simp; no_reg_writes_toI)"
      }
    },
    "CapabilityFromData": {
      "derivable_caps": {
        "stmts": ["Run (CapabilityFromData n arg1 arg2) t c \\<Longrightarrow> n = 128 \\<Longrightarrow> Capability_of_tag_word (arg1 !! 0) arg2 \\<in> derivable_caps s \\<Longrightarrow> c \\<in> derivable_caps s"],
        "proof": "(auto simp: CapabilityFromData_def)"
      }
    },
    "CheckCapability": {
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s"]
      }
    },
    "CapSetValue": {
      "derivable_caps": {
        "stmts": ["Run (CapSetValue arg0 arg1) t c \\<Longrightarrow> arg0 \\<in> derivable_caps s \\<Longrightarrow> CapIsTagSet arg0 \\<longrightarrow> \\<not>CapIsSealed arg0 \\<Longrightarrow> c \\<in> derivable_caps s"],
        "proof": "(non_cap_exp_insert_run s, unfold CapSetValue_def, derivable_capsI elim: update_subrange_addr_CapIsRepresentable_derivable_caps intro: update_subrange_if_derivable update_subrange_addr_CapWithTagClear_derivable)"
      }
    },
    "CapAdd": {
      "derivable_caps": {
        "stmts": ["Run (CapAdd arg0 arg1) t c \\<Longrightarrow> arg0 \\<in> derivable_caps s \\<Longrightarrow> CapIsTagSet arg0 \\<longrightarrow> \\<not>CapIsSealed arg0 \\<Longrightarrow> c \\<in> derivable_caps s"],
        "proof": "(non_cap_exp_insert_run s, unfold CapAdd_def, derivable_capsI elim: update_subrange_addr_CapIsRepresentableFast_derivable)"
      }
    },
    "CapAdd__1": {
      "derivable_caps": {
        "stmts": ["Run (CapAdd__1 arg0 arg1) t c \\<Longrightarrow> arg0 \\<in> derivable_caps s \\<Longrightarrow> CapIsTagSet arg0 \\<longrightarrow> \\<not>CapIsSealed arg0 \\<Longrightarrow> c \\<in> derivable_caps s"]
      }
    },
    "CapSetOffset": {
      "derivable_caps": {
        "stmts": ["Run (CapSetOffset arg0 arg1) t c \\<Longrightarrow> arg0 \\<in> derivable_caps s \\<Longrightarrow> CapIsTagSet arg0 \\<longrightarrow> \\<not>CapIsSealed arg0 \\<Longrightarrow> c \\<in> derivable_caps s"],
        "proof": "(non_cap_exp_insert_run s, unfold CapSetOffset_def, derivable_capsI)"
      }
    },
    "CapSetBounds": {
      "derivable_caps": {
        "stmts": ["Run (CapSetBounds arg0 arg1 arg2) t c \\<Longrightarrow> arg0 \\<in> derivable_caps s \\<Longrightarrow> CapIsTagSet arg0 \\<longrightarrow> \\<not>CapIsSealed arg0 \\<Longrightarrow> c \\<in> derivable_caps s"],
        "proof": "- (* TODO *)"
      }
    },
    "CapSquashPostLoadCap": {
      "derivable_caps": {
        "stmts": ["Run (CapSquashPostLoadCap arg0 arg1) t c \\<Longrightarrow> arg0 \\<in> derivable_caps s \\<Longrightarrow> c \\<in> derivable_caps (run s t)"]
      }
    },
    "X_set": {
      "traces_enabled": {
        "assms": ["LENGTH('a) \\<in> {32, 64}"],
        "stmts": ["traces_enabled (X_set arg0 arg1 (arg2 :: 'a::len word)) s"],
        "proof": "(traces_enabledI assms: assms)"
      }
    },
    "SP_set": {
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "LENGTH('a) \\<in> {32, 64}"],
        "stmts": ["traces_enabled (SP_set arg0 (arg1 :: 'a::len word)) s"],
        "proof": "(traces_enabledI assms: assms)"
      }
    },
    "BaseReg_set": {
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "VA_derivable arg1 s"]
      }
    },
    "BranchXToCapability": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms intro: enabled_branch_target_set_0th derivable_enabled_branch_target)"
      }
    },
    "DDC_EL2_CapSysRegRead_0d45f0beb99400e0": {
      "derivable_caps": {
        "proof": "- (* TODO: impossible EL case *)"
      }
    },
    "execute_aarch64_instrs_system_register_cpsr": {
      "non_cap_exp": {
        "proof": "(cases arg0; simp; non_cap_expI)"
      },
      "no_reg_writes_to": {
        "proof": "(cases arg0; simp; no_reg_writes_toI)"
      },
      "traces_enabledI": {
        "proof": "(traces_enabledI assms: assms elim: unat_le_add_vec_int_elim intro: unat_add_vec_int_plus_le)"
      }
    },
    "execute_aarch64_instrs_system_register_system": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "\\<not>(sys_op0 = 3 \\<and> sys_op1 \\<in> {0, 4, 6} \\<and> sys_op2 = 2 \\<and> sys_crm = 12)"],
        "stmts": ["traces_enabled (execute_aarch64_instrs_system_register_system read sys_crm sys_crm sys_op0 sys_op1 sys_op2 t) s"]
      }
    },
    "ReduceCombine": {
      "traces_enabled": {
        "unfolding": [],
        "proof": "(cases arg0; simp; traces_enabledI assms: assms)"
      },
      "non_mem_exp": {
        "proof": "(cases arg0; simp; non_mem_expI)"
      },
      "no_reg_writes_to": {
        "proof": "(cases arg0; simp; no_reg_writes_toI)"
      },
      "runs_no_reg_writes_to": {
        "proof": "(cases arg0; simp; no_reg_writes_toI)"
      }
    },
    "Reduce": {
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "arg2 \\<in> {16, 32, 64}", "nat arg2 \\<le> size arg1", "LENGTH('esize) = nat arg2"],
        "stmts": ["traces_enabled (Reduce arg0 arg1 arg2 :: 'esize::len word M) s"]
      }
    },
    "FPRecipEstimate": {
      "no_reg_writes_to": {
        "proof": "(unfold FPRecipEstimate_def bind_assoc, no_reg_writes_toI intro: no_reg_writes_to_if_no_asm)"
      },
      "runs_no_reg_writes_to": {
        "proof": "(unfold FPRecipEstimate_def bind_assoc, no_reg_writes_toI intro: runs_no_reg_writes_to_if_no_asm)"
      }
    },
    "execute_aarch64_instrs_system_hints": {
      "traces_enabled": {
        "unfolding": [],
        "proof": "(cases arg0; simp; traces_enabledI assms: assms)"
      },
      "non_mem_exp": {
        "proof": "(cases arg0; simp; non_mem_expI)"
      }
    },
    "AArch64_MemSingle_read": {
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s"]
      },
      "traces_enabled_mem": {
        "assms": ["translate_address (unat arg0) \\<noteq> None \\<longrightarrow> load_enabled s arg2 (unat arg0) arg1 False"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else)"
      }
    },
    "AArch64_MemSingle_set": {
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s"]
      },
      "traces_enabled_mem": {
        "assms": ["translate_address (unat arg0) \\<noteq> None \\<longrightarrow> store_enabled s arg2 (unat arg0) arg1 arg4 False", "LENGTH('a) = 8 * nat arg1"],
        "stmts": ["traces_enabled (AArch64_MemSingle_set arg0 arg1 arg2 arg3 (arg4 :: 'a::len word)) s"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else translate_address_aligned32_plus16)"
      }
    },
    "AArch64_TaggedMemSingle": {
      "derivable_caps": {
        "assms": ["Run (AArch64_TaggedMemSingle addr sz acctype wasaligned) t a", "LENGTH('a) = nat sz * 8"],
        "stmts": ["Capability_of_tag_word (vec_of_bits [access_vec_dec (fst a) 0] !! 0) (slice (snd a :: 'a::len word) 0 128) \\<in> derivable_caps (run s t)"],
        "using": ["assms"],
        "unfolding": ["AArch64_TaggedMemSingle_def"],
        "proof": "(auto simp: test_bit_of_bl elim!: Run_bindE Run_ifE ReadTaggedMem_lower_derivable[THEN derivable_caps_run_imp])"
      },
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s"]
      },
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) (nat arg1)", "load_enabled s arg2 (unat arg0) 16 True", "arg1 = 32 \\<Longrightarrow> load_enabled s arg2 (unat arg0 + 16) 16 True", "arg1 = 32 \\<Longrightarrow> load_enabled s arg2 (unat arg0) 32 False"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else translate_address_aligned32_plus16)"
      }
    },
    "AArch64_TaggedMemSingle__1": {
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "Capability_of_tag_word (tags !! 0) (ucast data) \\<in> derivable_caps s", "sz = 32 \\<Longrightarrow> Capability_of_tag_word (tags !! 1) (Word.slice 128 data) \\<in> derivable_caps s"],
        "stmts": ["traces_enabled (AArch64_TaggedMemSingle__1 addr sz acctype wasaligned (tags :: 't::len word) (data :: 'd::len word)) s"],
        "proof": "(traces_enabledI assms: assms)"
      },
      "traces_enabled_mem": {
        "assms": ["aligned (unat addr) (nat sz)", "store_enabled s arg2 (unat addr) 16 (ucast data :: 128 word) (tags !! 0)", "sz = 32 \\<Longrightarrow> store_enabled s arg2 (unat addr + 16) 16 (Word.slice 128 data :: 128 word) (tags !! 1)", "LENGTH('t) = nat sz div 16", "LENGTH('d) = 8 * nat sz"],
        "stmts": ["traces_enabled (AArch64_TaggedMemSingle__1 addr sz acctype wasaligned (tags :: 't::len word) (data :: 'd::len word)) s"],
        "proof": "(traces_enabledI assms: assms intro: access_enabled_runI simp: exp_fails_if_then_else translate_address_aligned32_plus16)"
      }
    },
    "AArch64_CapabilityTag": {
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 16 \\<longrightarrow> load_enabled s arg1 (unat arg0) 16 True"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else)"
      }
    },
    "AArch64_CapabilityTag_set": {
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "arg2 = 0"],
        "proof": "(traces_enabledI assms: assms)"
      },
      "traces_enabled_mem": {
        "assms": ["\\<And>data :: 128 word. aligned (unat vaddr) 16 \\<longrightarrow> store_enabled s acctype (unat vaddr) 16 data False", "tag = 0"],
        "stmts": ["traces_enabled (AArch64_CapabilityTag_set vaddr acctype tag) s"],
        "unfolding": ["AArch64_CapabilityTag_set_def", "AArch64_TranslateAddress_def", "bind_assoc"],
        "proof": "- (* TODO: traces_enabledI assms: assms simp: exp_fails_if_then_else IsFault_def translate_correct *)"
      }
    },
    "_WriteTags": {
      "traces_enabled_mem": {
        "assms": ["\\<And>data :: 128 word. access_enabled s Store (unat (FullAddress_address (AddressDescriptor_paddress desc))) 16 (mem_bytes_of_word data) B0", "n = 1", "tags = 0"],
        "stmts": ["traces_enabled (WriteTags desc sz tags addrdesc) s"],
        "unfolding": ["WriteTags_def", "bind_assoc"]
      }
    },
    "Mem_read": {
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s"],
        "proof": "(traces_enabledI assms: assms)"
      },
      "traces_enabled_mem": {
        "assms": ["load_enabled s acctype (unat vaddr) sz False"],
        "stmts": ["traces_enabled (Mem_read0 vaddr sz acctype) s"],
        "proof": "(traces_enabledI assms: assms simp: AArch64_MemSingle_read_translate_address_Some)"
      }
    },
    "Mem_set": {
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s"],
        "proof": "(traces_enabledI assms: assms)"
      },
      "traces_enabled_mem": {
        "assms": ["store_enabled s acctype (unat vaddr) sz data False", "LENGTH('a) = 8 * nat sz", "sz \\<le> 16"],
        "stmts": ["traces_enabled (Mem_set0 vaddr sz acctype (data :: 'a::len word)) s"],
        "proof": "(traces_enabledI assms: assms simp: AArch64_MemSingle_set_translate_address_Some)"
      }
    },
    "MemC_read": {
      "derivable_caps": {
        "stmts": ["Run (MemC_read arg0 arg1) t c \\<Longrightarrow> use_mem_caps \\<Longrightarrow> c \\<in> derivable_caps (run s t)"],
        "proof": "(derivable_capsI)"
      },
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s"]
      },
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 16 \\<longrightarrow> load_enabled s arg1 (unat arg0) 16 True"],
        "proof": "(traces_enabledI assms: assms)"
      }
    },
    "MemC_set": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms simp: update_subrange_vec_dec_test_bit)"
      },
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 16 \\<longrightarrow> store_enabled s arg1 (unat arg0) 16 (ucast arg2 :: 128 word) (CapIsTagSet arg2)"],
        "proof": "(traces_enabledI assms: assms simp: update_subrange_vec_dec_test_bit)"
      }
    },
    "MemCP": {
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 32", "load_enabled s arg1 (unat arg0) 16 True", "load_enabled s arg1 (unat arg0 + 16) 16 True", "load_enabled s arg1 (unat arg0) 32 False"],
        "proof": "(traces_enabledI assms: assms)"
      }
    },
    "MemCP__1": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms simp: update_subrange_vec_dec_test_bit update_subrange_vec_dec_word_cat_cap_pair slice_128_cat_cap_pair)"
      },
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 32", "store_enabled s arg1 (unat arg0) 16 (ucast arg2 :: 128 word) (CapIsTagSet arg2)", "store_enabled s arg1 (unat arg0 + 16) 16 (ucast arg3 :: 128 word) (CapIsTagSet arg3)"],
        "proof": "(traces_enabledI assms: assms simp: DataFromCapability_def update_subrange_vec_dec_test_bit update_subrange_vec_dec_word_cat_cap_pair slice_128_cat_cap_pair)"
      }
    },
    "MemAtomicC": {
      "derivable_caps": {
        "assms": ["Run (MemAtomicC arg0 arg1 arg2 arg3 arg4) t c", "arg2 \\<in> derivable_caps s", "use_mem_caps"],
        "stmts": ["c \\<in> derivable_caps (run s t)"],
        "using": ["assms(1)"],
        "unfolding": ["MemAtomicC_def"],
        "proof": "- (derivable_capsI assms: assms(2) intro: assms(3))"
      },
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "arg2 \\<in> derivable_caps s"],
        "proof": "(traces_enabledI assms: assms simp: update_subrange_vec_dec_test_bit)"
      },
      "traces_enabled_mem": {
        "assms": ["aligned (unat arg0) 16 \\<longrightarrow> load_enabled s arg3 (unat arg0) 16 True", "aligned (unat arg0) 16 \\<longrightarrow> store_enabled s arg4 (unat arg0) 16 (ucast arg2 :: 128 word) (CapIsTagSet arg2)", "arg2 \\<in> derivable_caps s"],
        "unfolding": ["MemAtomicC_def", "AArch64_TranslateAddressForAtomicAccess_def", "Let_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: DataFromCapability_def update_subrange_vec_dec_test_bit test_bit_of_bl exp_fails_if_then_else)"
      }
    },
    "MemAtomicCompareAndSwap": {
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s"]
      },
      "traces_enabled_mem": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "VA_derivable base s", "8 dvd LENGTH('a)"],
        "stmts": ["traces_enabled (MemAtomicCompareAndSwap base expval (newval :: 'a::len word) ldacctype stacctype) s"],
        "unfolding": ["MemAtomicCompareAndSwap_def", "AArch64_TranslateAddressForAtomicAccess_def", "Let_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else)"
      }
    },
    "MemAtomicCompareAndSwapC": {
      "derivable_caps": {
        "assms": ["Run (MemAtomicCompareAndSwapC arg0 arg1 arg2 arg3 arg4 arg5) t c", "arg2 \\<in> derivable_caps s", "arg3 \\<in> derivable_caps s", "{''PCC''} \\<subseteq> accessible_regs s", "use_mem_caps"],
        "stmts": ["c \\<in> derivable_caps (run s t)"],
        "using": ["assms(1)"],
        "unfolding": ["MemAtomicCompareAndSwapC_def"],
        "proof": "- (derivable_capsI assms: assms(2-4) intro: assms(5))"
      },
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "arg2 \\<in> derivable_caps s", "arg3 \\<in> derivable_caps s"],
        "proof": "(traces_enabledI assms: assms simp: update_subrange_vec_dec_test_bit)"
      },
      "traces_enabled_mem": {
        "assms": ["aligned (unat addr) 16 \\<longrightarrow> load_enabled s ldacctype (unat addr) 16 True", "aligned (unat addr) 16 \\<longrightarrow> store_enabled s stacctype (unat addr) 16 (ucast newcap :: 128 word) (CapIsTagSet newcap)", "newcap \\<in> derivable_caps s"],
        "stmts": ["traces_enabled (MemAtomicCompareAndSwapC va addr expcap newcap ldacctype stacctype) s"],
        "unfolding": ["MemAtomicCompareAndSwapC_def", "AArch64_TranslateAddressForAtomicAccess_def", "Let_def bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else update_subrange_vec_dec_test_bit)"
      }
    },
    "MemAtomic": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s"]
      },
      "traces_enabled_mem": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "VA_derivable base s", "8 dvd LENGTH('a)"],
        "stmts": ["traces_enabled (MemAtomic base op (data :: 'a::len word) ldacctype stacctype) s"],
        "unfolding": ["MemAtomic_def", "AArch64_TranslateAddressForAtomicAccess_def", "Let_def", "bind_assoc"],
        "proof": "(traces_enabledI assms: assms simp: exp_fails_if_then_else)"
      }
    },
    "AArch64_AutoGen_SysRegRead": {
      "traces_enabled": {
        "unfolding": [],
        "proof": "(unfold AArch64_AutoGen_SysRegRead_def, traces_enabledI intro: assms[THEN subset_trans[rotated]])"
      }
    },
    "AArch64_AutoGen_SysOpsWrite": {
      "traces_enabled_mem": {
	"extra_assms": ["\\<not>(CRm = 4 \\<and> CRn = 7 \\<and> op0 = 1 \\<and> op1 = 3 \\<and> op2 = 1)"],
	"stmts": ["traces_enabled (AArch64_AutoGen_SysOpsWrite el op0 op1 CRn op2 CRm val) s"]
      }
    },
    "AArch64_SysInstr": {
      "traces_enabled_mem": {
	"extra_assms": ["\\<not>(word_of_int CRm = (4 :: 4 word) \\<and> word_of_int CRn = (7 :: 4 word) \\<and> word_of_int op0 = (1 :: 2 word) \\<and> word_of_int op1 = (3 :: 3 word) \\<and> word_of_int op2 = (1 :: 3 word))"],
	"stmts": ["traces_enabled (AArch64_SysInstr op0 op1 CRn CRm op2 val) s"]
      }
    },
    "AArch64_AutoGen_SysRegWrite": {
      "no_reg_writes_to": {
        "proof": "(unfold AArch64_AutoGen_SysRegWrite_def bind_assoc, no_reg_writes_toI intro: no_reg_writes_to_if_no_asm)"
      },
      "runs_no_reg_writes_to": {
        "proof": "(unfold AArch64_AutoGen_SysRegWrite_def bind_assoc, no_reg_writes_toI intro: runs_no_reg_writes_to_if_no_asm)"
      },
      "traces_enabled": {
        "proof": "(traces_enabled_step intro: assms)+"
      }
    },
    "AArch64_SysRegWrite": {
      "traces_enabled": {
        "assms": ["{''PCC''} \\<subseteq> accessible_regs s", "\\<not>(op0 = 3 \\<and> op1 \\<in> {0, 4, 6} \\<and> op2 = 2 \\<and> crn = 12)"],
        "stmts": ["traces_enabled (AArch64_SysRegWrite op0 op1 crn crm op2 val) s"]
      },
      "non_mem_exp": {
        "stmts": ["\\<not>(arg0 = 3 \\<and> arg2 = 12 \\<and> (arg1 = 6 \\<or> arg1 = 4 \\<or> arg1 = 0) \\<and> arg4 = 2 \\<and> arg3 = 0 \\<and> arg5 !! 1) \\<Longrightarrow> non_mem_exp (AArch64_SysRegWrite arg0 arg1 arg2 arg3 arg4 arg5)"]
      }
    },
    "DC_ZVA": {
      "traces_enabled_mem": {
	"assms": ["{''PCC''} \\<subseteq> accessible_regs s", "store_enabled s AccType_DCZVA (unat (Align arg0 64)) 64 (0 :: 512 word) False"],
	"proof": "(traces_enabledI assms: assms intro: traces_enabled_foreachM_index_list_inv2[where Inv = \"\\<lambda>idx _ memaddrdesc s. {''PCC''} \\<subseteq> accessible_regs s \\<and> FullAddress_address (AddressDescriptor_paddress memaddrdesc) = FullAddress_address (AddressDescriptor_paddress memaddrdesc0) + word_of_int idx\" and var_b = memaddrdesc0 for memaddrdesc0] store_enabled_data_paccess_enabled_subset[OF assms(2)] simp: DCZID_EL0_assm exp_fails_if_then_else aligned_unat_plus_distrib[where sz = 64] AArch64_FullTranslate_translate_address[THEN translate_address_aligned_iff] wi_hom_syms elim: Run_bindE)"
      }
    },
    "DC_ZVA_SysOpsWrite_13fdcf6641be2057": {
      "traces_enabled_mem": {
	"extra_assms": ["store_enabled s AccType_DCZVA (unat (Align arg6 64)) 64 (0 :: 512 word) False"]
      }
    },
    "CAP_DC_CVAU": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms intro: traces_enabled_bind)"
      }
    },
    "CAP_IC_IVAU": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms intro: traces_enabled_bind)"
      }
    },
    "VAToCapability": {
      "derivable_caps": {
        "stmts": ["Run (VAToCapability va) t c \\<Longrightarrow> VA_derivable va s \\<Longrightarrow> c \\<in> derivable_caps s"],
        "proof": "(auto simp: VA_derivable_def)"
      }
    },
    "execute_BLRS_C_C_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms intro: enabled_branch_target_CapUnseal_if_clear elim: branch_sealed_pair_enabled_pcc traces_enabled_C_set_29_branch_sealed_pair)"
      }
    },
    "execute_BLR_CI_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms intro: enabled_branch_target_CapUnseal_mem_cap traces_enabled_C_set_if_sentry elim: enabled_branch_target_CapSquashPostLoadCap Run_CSP_or_C_read_invoked_indirect_caps)"
      },
      "traces_enabled_mem": {
        "proof": "(traces_enabledI assms: assms elim: VADeref_load_enabled)"
      }
    },
    "execute_BRS_C_C_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms intro: enabled_branch_target_CapUnseal_if_clear elim: branch_sealed_pair_enabled_pcc traces_enabled_C_set_29_branch_sealed_pair)"
      }
    },
    "execute_BR_CI_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms intro: enabled_branch_target_CapUnseal_mem_cap traces_enabled_C_set_if_sentry elim: enabled_branch_target_CapSquashPostLoadCap Run_CSP_or_C_read_invoked_indirect_caps)"
      },
      "traces_enabled_mem": {
        "proof": "(traces_enabledI assms: assms elim: VADeref_load_enabled)"
      }
    },
    "execute_LDPBLR_C_C_C": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "0 \\<le> arg2", "arg2 \\<le> 31", "0 \\<le> arg1", "arg1 \\<le> 31", "arg2 = 29 \\<longrightarrow> arg1 \\<in> invoked_indirect_regs", "arg2 \\<noteq> 29 \\<longrightarrow> \\<not>invokes_indirect_caps", "is_indirect_branch"],
        "proof": "(traces_enabledI assms: assms intro: enabled_branch_target_CapUnseal_mem_cap traces_enabled_C_set_mem_cap[where n = arg2] elim: enabled_branch_target_CapSquashPostLoadCap)"
      },
      "traces_enabled_mem": {
        "proof": "(traces_enabledI assms: assms elim: VADeref_load_enabled)"
      }
    },
    "decode_LDPBLR_C_C_C": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "uint arg2 = 29 \\<longrightarrow> uint arg1 \\<in> invoked_indirect_regs", "uint arg2 \\<noteq> 29 \\<longrightarrow> \\<not>invokes_indirect_caps", "is_indirect_branch"]
      }
    },
    "execute_LDPBR_C_C_C": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "0 \\<le> arg2", "arg2 \\<le> 31", "0 \\<le> arg1", "arg1 \\<le> 31", "arg2 = 29 \\<longrightarrow> arg1 \\<in> invoked_indirect_regs", "arg2 \\<noteq> 29 \\<longrightarrow> \\<not>invokes_indirect_caps", "is_indirect_branch"],
        "proof": "(traces_enabledI assms: assms intro: enabled_branch_target_CapUnseal_mem_cap traces_enabled_C_set_mem_cap[where n = arg2] elim: enabled_branch_target_CapSquashPostLoadCap)"
      },
      "traces_enabled_mem": {
        "proof": "(traces_enabledI assms: assms elim: VADeref_load_enabled)"
      }
    },
    "decode_LDPBR_C_C_C": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "uint arg2 = 29 \\<longrightarrow> uint arg1 \\<in> invoked_indirect_regs", "uint arg2 \\<noteq> 29 \\<longrightarrow> \\<not>invokes_indirect_caps", "is_indirect_branch"]
      }
    },
    "execute_LDP_CC_RIAW_C": {
      "traces_enabled_mem": {
        "extra_assms": ["arg0 = AccType_NORMAL"]
      }
    },
    "execute_LDP_C_RIBW_C": {
      "traces_enabled_mem": {
        "extra_assms": ["arg0 = AccType_NORMAL"]
      }
    },
    "execute_LDP_C_RIB_C": {
      "traces_enabled_mem": {
        "extra_assms": ["arg0 = AccType_NORMAL"]
      }
    },
    "execute_RETS_C_C_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms intro: enabled_branch_target_CapUnseal_if_clear elim: branch_sealed_pair_enabled_pcc traces_enabled_C_set_29_branch_sealed_pair)"
      }
    },
    "execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms elim: Run_case_MemOp_LOAD_STORE_not_VAIsSealedCap_generic)"
      }
    },
    "execute_aarch64_instrs_memory_vector_single_no_wb": {
      "traces_enabled_mem": {
	"unfolding": ["execute_aarch64_instrs_memory_vector_single_no_wb_def", "bind_assoc", "Let_def", "case_prod_beta"],
	"proof": "(traces_enabledI assms: assms intro: traces_enabled_foreachM_index_list_inv[where Inv = \"\\<lambda>idx vars s. Inv_vector_single_no_wb ebytes idx address (fst (snd vars))\" and body = \"\\<lambda>s (vars :: ('esize word * 64 word * int)). (Mem_read0 (add_vec address (fst (snd vars))) ebytes _ :: 'esize word M) \\<bind> (\\<lambda>w. _ w vars :: ('esize word * 64 word * int) M)\" for address :: \"64 word\" and ebytes] traces_enabled_foreachM_index_list_inv[where Inv = \"\\<lambda>idx vars s. Inv_vector_single_no_wb ebytes idx address (fst vars)\" and body = \"\\<lambda>s (vars :: 64 word * 128 word * int). (V_read 128 (snd (snd vars)) :: 128 word M) \\<bind> (\\<lambda>w. (if arg4 = MemOp_LOAD then Mem_read0 (add_vec address (fst vars)) ebytes _ \\<bind> (\\<lambda>w'. _ w' w vars :: 128 word M) else (_ w vars :: 128 word M)) \\<bind> (\\<lambda>w'. _ w' w vars :: (64 word * 128 word * int) M))\" for address :: \"64 word\" and ebytes] elim: Run_bindE[where thesis = \"Inv_vector_single_no_wb _ (_ + 1) _ _\"] Run_ifE[where thesis = \"Inv_vector_single_no_wb _ (_ + 1) _ _\"] Mem_read0_valid_address Mem_set0_valid_address simp: unat_0_iff)"
      }
    },
    "execute_aarch64_instrs_memory_exclusive_pair": {
      "traces_enabled_mem": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "LENGTH('regsize) \\<in> {32, 64} \\<and> arg2 \\<in> {32, 64} \\<and> arg1 = 2 * arg2"],
        "stmts": ["traces_enabled (execute_aarch64_instrs_memory_exclusive_pair arg0 arg1 arg2 arg3 arg4 True (arg6 :: 'regsize::len itself) arg7 arg8 arg9) s"]
      }
    },
    "execute_aarch64_instrs_memory_exclusive_single": {
      "traces_enabled_mem": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "LENGTH('regsize) \\<in> {32, 64} \\<and> arg2 \\<in> {8, 16, 32, 64} \\<and> arg1 = arg2"],
        "stmts": ["traces_enabled (execute_aarch64_instrs_memory_exclusive_single arg0 arg1 arg2 arg3 arg4 False (arg6 :: 'regsize::len itself) arg7 arg8 arg9) s"]
      }
    },
    "execute_aarch64_instrs_memory_vector_multiple_no_wb": {
      "traces_enabled_mem": {
	"assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "LENGTH('esize) \\<in> {8, 16, 32, 64}", "LENGTH('datasize) \\<in> {64, 128}", "arg1 = int LENGTH('datasize) div int LENGTH('esize)", "arg6 \\<in> {1, 2, 3, 4}", "arg7 \\<in> {1, 2, 3, 4}"],
	"stmts": ["traces_enabled (execute_aarch64_instrs_memory_vector_multiple_no_wb (arg0 :: 'datasize::len itself) arg1 (arg2 :: 'esize::len itself) arg3 arg4 arg5 arg6 arg7 arg8 arg9) s"],
	"unfolding": ["execute_aarch64_instrs_memory_vector_multiple_no_wb_def", "bind_assoc", "Let_def", "case_prod_beta"],
	"proof": "(traces_enabledI assms: assms intro: traces_enabled_triple_foreachM_index_list_inv[where Inv = \"Inv_vector_multiple_no_wb (LENGTH('esize) div 8) arg1 arg7 base\" and body = \"\\<lambda>idx_a idx_b idx_c (vars :: (64 word * 'datasize word * int)). (V_read _ (snd (snd vars)) :: 'datasize word M) \\<bind> (\\<lambda>w. (if arg4 = MemOp_LOAD then Mem_read0 (add_vec base (fst vars)) _ _ \\<bind> (_ w idx_b vars :: 'esize word \\<Rightarrow> 'datasize word M) else _ w base idx_b vars) \\<bind> (_ vars :: 'datasize word \\<Rightarrow> (64 word * 'datasize word * int) M))\" for base :: \"64 word\"] elim: Run_bindE[where thesis = \"Inv_vector_multiple_no_wb _ _ _ _ _ _ (_ + 1) _ _\"] Run_ifE[where thesis = \"Inv_vector_multiple_no_wb _ _ _ _ _ _ (_ + 1) _ _\"] Inv_vector_multiple_no_wb_step Mem_read0_valid_address Mem_set0_valid_address simp: unat_0_iff)"
      }
    },
    "execute_aarch64_instrs_memory_pair_simdfp_no_alloc": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('datasize) \\<in> {32, 64, 128, 256}", "\\<not>arg5", "\\<not>arg8"]
      }
    },
    "execute_aarch64_instrs_memory_pair_general_no_alloc": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('datasize) \\<in> {32, 64}", "\\<not>arg8"]
      }
    },
    "execute_aarch64_instrs_memory_pair_simdfp_post_idx": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('datasize) \\<in> {32, 64, 128, 256}", "arg2 \\<noteq> MemOp_PREFETCH"]
      }
    },
    "execute_aarch64_instrs_memory_pair_general_post_idx": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('datasize) \\<in> {32, 64}", "arg2 \\<noteq> MemOp_PREFETCH"]
      }
    },
    "execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('datasize) \\<in> {8, 16, 32, 64, 128, 256, 512, 1024}", "arg2 \\<noteq> MemOp_PREFETCH"]
      }
    },
    "execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('regsize) \\<in> {32, 64}", "int LENGTH('datasize) \\<in> {8, 16, 32, 64}", "arg2 \\<noteq> MemOp_PREFETCH"]
      }
    },
    "execute_aarch64_instrs_memory_single_simdfp_register": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "arg7 \\<in> {0, 1, 2, 3, 4, 5, 6, 7}", "int LENGTH('datasize) \\<in> {8, 16, 32, 64, 128, 256, 512, 1024}", "arg4 \\<noteq> MemOp_PREFETCH"]
      },
      "traces_enabled_mem": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s"]
      }
    },
    "execute_aarch64_instrs_memory_single_general_register": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "arg8 \\<in> {0, 1, 2, 3}", "int LENGTH('regsize) \\<in> {32, 64}", "int LENGTH('datasize) \\<in> {8, 16, 32, 64}", "\\<not>arg11"]
      }
    },
    "execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('regsize) \\<in> {32, 64}", "int LENGTH('datasize) \\<in> {8, 16, 32, 64}", "\\<not>arg8"]
      }
    },
    "execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('datasize) \\<in> {8, 16, 32, 64, 128, 256, 512, 1024}", "\\<not>arg7"]
      }
    },
    "execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('regsize) \\<in> {32, 64}", "int LENGTH('datasize) \\<in> {8, 16, 32, 64}", "\\<not>arg9"]
      }
    },
    "execute_aarch64_instrs_memory_single_general_immediate_unsigned": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "int LENGTH('regsize) \\<in> {32, 64}", "int LENGTH('datasize) \\<in> {8, 16, 32, 64}", "\\<not>arg9"]
      }
    },
    "execute_LDCT_R_R__": {
      "traces_enabled_mem": {
	"proof": "(traces_enabledI assms: assms intro: traces_enabled_foreachM_index_list_inv2[where Inv = \"\\<lambda>idx addr _ s. addr = addr0 + word_of_int (idx * 16) \\<and> {''PCC'', ''_R29''} \\<subseteq> accessible_regs s \\<and> (idx = 0 \\<or> valid_address AccType_NORMAL (unat addr0))\" and var_a = addr0 for addr0] elim: VADeref_load_enabled AArch64_CapabilityTag_valid_address simp: wi_hom_syms)"
      }
    },
    "execute_BUILD_C_C_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms elim: CapIsSubSetOf_WithTagSet_derivable Run_or_boolM_E Run_bindE simp: CapIsBaseAboveLimit_get_base_leq_get_limit)"
      }
    },
    "execute_CHKSSU_C_CC_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms elim: CapIsSubSetOf_CapUnseal_derivable Run_and_boolM_E)"
      }
    },
    "execute_CSEAL_C_C_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms elim: Run_and_boolM_E CapIsInBounds_cursor_in_mem_region)"
      }
    },
    "execute_SEAL_C_CC_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms simp: Run_and_boolM_True_iff elim: CapIsInBounds_cursor_in_mem_region)"
      }
    },
    "execute_SEAL_C_CI_C": {
      "traces_enabled": {
        "assms": ["{''PCC'', ''_R29''} \\<subseteq> accessible_regs s", "arg1 \\<in> {0, 1, 2, 3}"],
        "proof": "(traces_enabledI assms: assms intro: CapSetObjectType_sentry_derivable)"
      }
    },
    "decode_SEAL_C_CI_C": {
      "traces_enabled": {
        "proof": "(cases arg0 rule: exhaustive_2_word) (use assms in \\<open>auto intro: traces_enabled_execute_SEAL_C_CI_C\\<close>)"
      }
    },
    "execute_UNSEAL_C_CC_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms intro: CapUnseal_check_global_derivable simp: Run_and_boolM_True_iff)"
      }
    },
    "execute_SCTAG_C_CR_C": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms simp: Run_and_boolM_True_iff IsTagSettingDisabled_not_False)"
      }
    },
    "execute_STCT_R_R__": {
      "traces_enabled": {
        "proof": "(traces_enabledI assms: assms simp: Run_and_boolM_True_iff IsTagSettingDisabled_not_False)"
      },
      "traces_enabled_mem": {
        "proof": "(traces_enabledI assms: assms elim: VADeref_store_enabled simp: Run_and_boolM_True_iff IsTagSettingDisabled_not_False)"
      }
    }
  },
  "invoked_regs": {
    "execute_BLRR_C_C": ["arg1"],
    "decode_BLRR_C_C": ["uint arg1"],
    "execute_BLRS_C_C": ["arg1"],
    "decode_BLRS_C_C": ["uint arg1"],
    "execute_BLRS_C_C_C": ["arg1", "arg2"],
    "decode_BLRS_C_C_C": ["uint arg0", "uint arg2"],
    "execute_BLR_C_C": ["arg1"],
    "decode_BLR_C_C": ["uint arg1"],
    "execute_BRR_C_C": ["arg1"],
    "decode_BRR_C_C": ["uint arg1"],
    "execute_BRS_C_C": ["arg1"],
    "decode_BRS_C_C": ["uint arg1"],
    "execute_BRS_C_C_C": ["arg1", "arg2"],
    "decode_BRS_C_C_C": ["uint arg0", "uint arg2"],
    "execute_BR_C_C": ["arg1"],
    "decode_BR_C_C": ["uint arg1"],
    "execute_RETR_C_C": ["arg1"],
    "decode_RETR_C_C": ["uint arg1"],
    "execute_RETS_C_C": ["arg1"],
    "decode_RETS_C_C": ["uint arg1"],
    "execute_RETS_C_C_C": ["arg1", "arg2"],
    "decode_RETS_C_C_C": ["uint arg0", "uint arg2"],
    "execute_RET_C_C": ["arg1"],
    "decode_RET_C_C": ["uint arg1"]
  },
  "invoked_indirect_regs": {
    "execute_BLR_CI_C": ["arg1"],
    "decode_BLR_CI_C": ["uint arg1"],
    "execute_BR_CI_C": ["arg1"],
    "decode_BR_CI_C": ["uint arg1"],
    "execute_LDPBLR_C_C_C": ["arg1"],
    "decode_LDPBLR_C_C_C": ["uint arg1"],
    "execute_LDPBR_C_C_C": ["arg1"],
    "decode_LDPBR_C_C_C": ["uint arg1"]
  },
  "cap_load_funs": ["_ReadTaggedMem"],
  "skips": [
    "__ReadRAM",
    "__WriteRAM",
    "_Mem_read",
    "_Mem_set",
    "_ReadMem",
    "_ReadTaggedMem",
    "_ReadTags",
    "_WriteMem",
    "_WriteTaggedMem",
    "_WriteTags",
    "AArch32_AutoGen_ArchitectureReset",
    "AArch64_AutoGen_ArchitectureReset",
    "AArch64_IMPDEFResets",
    "__Reset",
    "ResetControlRegisters",
    "AArch64_ResetControlRegisters",
    "AArch64_ResetSpecialRegisters",
    "TakeReset",
    "AArch64_TakeReset"
  ]
}
